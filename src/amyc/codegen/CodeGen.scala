package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{And => AmyAnd, Call => AmyCall, Div => AmyDiv, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm.{Instructions, _}
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        //  case class Variable(name: Name) extends Expr
        case Variable(name) => GetLocal(locals(name))
        //  case class IntLiteral(value: Int) extends Literal[Int]
        case IntLiteral(v) => Const(v)
        //  case class BooleanLiteral(value: Boolean) extends Literal[Boolean]
        case BooleanLiteral(v) => if (v) Const(1) else Const(0)
        //  case class StringLiteral(value: String) extends Literal[String]
        case StringLiteral(v) => mkString(v)
        //  case class UnitLiteral() extends Literal[Unit] { val value: Unit = () }
        case UnitLiteral() => Const(0)
        //  case class Plus(lhs: Expr, rhs: Expr) extends Expr
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Add
        //  case class Minus(lhs: Expr, rhs: Expr) extends Expr
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Sub
        //  case class Times(lhs: Expr, rhs: Expr) extends Expr
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Mul
        //  case class Div(lhs: Expr, rhs: Expr) extends Expr
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Div
        //  case class Mod(lhs: Expr, rhs: Expr) extends Expr
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Rem
        //  case class LessThan(lhs: Expr, rhs: Expr) extends Expr
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Lt_s
        //  case class LessEquals(lhs: Expr, rhs: Expr) extends Expr
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Le_s
        //  case class And(lhs: Expr, rhs: Expr) extends Expr
        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.And
        //  case class Or(lhs: Expr, rhs: Expr) extends Expr
        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Or
        //  case class Equals(lhs: Expr, rhs: Expr) extends Expr
        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Instructions.Eq
        //  case class Concat(lhs: Expr, rhs: Expr) extends Expr
        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)
        //  case class Not(e: Expr) extends Expr
        case Not(e) => cgExpr(e)<:>Instructions.Eqz
        //  case class Neg(e: Expr) extends Expr
        case Neg(e) => Const(0) <:> cgExpr(e) <:> Instructions.Sub
        //  case class Call(qname: QualifiedName, args: List[Expr]) extends Expr
        case AmyCall(qname, args) => {
          //verifier si on a affaire à une fonction ou un constructeur
          val functionMaybe = table.getFunction(qname)
          if(functionMaybe != None){
            val functionName = fullName(functionMaybe.get.owner, qname)
            //on jump au code de la focntion
            args.map(cgExpr(_))<:>Call(functionName)
          }

          //C'EST PAS UNE FONCTION
          else {
            val constructor = table.getConstructor(qname)
            //Verifier juste au cas ou
            if(constructor == None) Unreachable

            val constructorIndex = constructor.get.index

            //faire un pointeur sur l'endroit où se trouve actuellement la memory
            val bIndex = lh.getFreshLocal()
            def generateCodeArgs():Code = {
              //GetLocal(bIndex) : on va au début de la memory ou se trouve l'ancienne memory
              args.zipWithIndex.map(a=> GetLocal(bIndex)<:>adtField(a._2)<:>cgExpr(a._1)<:>Store)
            }


            //1) Save old memory boundary
            //premier getGlobal : On store l'index d'où se trouve le pointeur de la fin de la memory
            //SetLocal: on précise à quoi correspond ce pointeur qu'on a storé
            //GetGlobal : vu que le SetLocal a consumé le getGlobal il faut le refaire pour l'avoir sur la memory
            GetGlobal(memoryBoundary)<:>SetLocal(bIndex)<:>GetGlobal(memoryBoundary)<:>
              //2) Increment memory boundary by the size of the allocated ADT
              adtField(constructorIndex)<:>
              //3) Store the constructor index to address b
              //GetGlobal: on revient à la fin de la memory
              //Const(constructorIndex): vu que l'index du constructor c'est juste un int on le met sur la stack
              //Store : pour mettre sur la memory (pas la stack)
              SetGlobal(memoryBoundary)<:> GetGlobal(memoryBoundary)<:> Const(constructorIndex)<:>Store<:>
              //4) For each field of the constructor, generate code for it and
              // store it in memory in the correct offset from b
              generateCodeArgs<:>
              //5)Push b to the stack (base address of the ADT)
              GetLocal(bIndex)
          }
        }
        //  // The ; operator
        //  case class Sequence(e1: Expr, e2: Expr) extends Expr
        case Sequence(e1, e2) => cgExpr(e1)<:>Drop<:>cgExpr(e2)
        //  // Local variable definition
        //  case class Let(df: ParamDef, value: Expr, body: Expr) extends Expr
        case Let(df, value, body) =>
          val newId = lh.getFreshLocal()
          cgExpr(value) <:> SetLocal(newId) <:> cgExpr(body)(locals.updated(df.name, newId), lh)
        //  // If-then-else
        //  case class Ite(cond: Expr, thenn: Expr, elze: Expr) extends Expr
        case Ite(cond, thenn, elze) =>
          Instructions.If_i32 <:> cgExpr(cond) <:> cgExpr(thenn) <:> Instructions.Else <:> cgExpr(elze) <:> Instructions.End
        //  // Pattern matching
        //  case class Match(scrut: Expr, cases: List[MatchCase]) extends Expr {
        //    require(cases.nonEmpty)
        //  }

        /*
          match a {
          case 7 => 42
          case _ => 0
        }

        a mb(7 eq) if 42 else mb(1) if 0
        */
        case Match(scrut, cases) => {

          var maplocals : Map[Identifier, Int] = Map()

          def matchAndBind(p: Pattern) : Code = p match{
            //case class WildcardPattern() extends Pattern // _
            case WildcardPattern() => Drop<:>Const(1)
            //  case class IdPattern(name: Name) extends Pattern // x
            case IdPattern(name : Name) =>
              val newId = lh.getFreshLocal()
              maplocals = maplocals + (name -> newId)
              SetLocal(newId)<:>Const(1)
            //  case class LiteralPattern[+T](lit: Literal[T]) extends Pattern // 42, true
            case LiteralPattern(lit) => cgExpr(lit)<:>Eq
            //  case class CaseClassPattern(constr: QualifiedName, args: List[Pattern]) extends Pattern // C(arg1, arg2)
            case CaseClassPattern(constr, args) =>
              val actualIndex = lh.getFreshLocal()
              //récupérer type scrut
              val indexScrut = SetLocal(actualIndex)<:>GetLocal(actualIndex)<:>Load
              //maintenant faut récupérer l'idex du constructeur
              val indexConstr = Const(table.getConstructor(constr).get.index)
              val constrequ = indexScrut<:>indexConstr<:>Eq

              //vérifier si tous les args sont les mêmes, retourner arg1==arg1, arg2=arg2, ....
              def verifyArgs():Code = {
                if(args.isEmpty) Instructions.Const(1)
                else args.zipWithIndex.map(x => GetLocal(actualIndex)<:>adtField(x._2)<:>Load<:>matchAndBind(x._1))<:>
                  addAnd(args.size-1)
              }

              def addAnd(nb:Int):Code = {
                var cd:Code=And
                var n = nb-1
                while(n>0){
                  cd = cd<:>And
                  n-1
                }
                cd
              }

              //si const pareil alors vérifier arg et sinon return 0
              Instructions.If_i32<:>constrequ<:>verifyArgs()<:>Else<:>Const(0)<:>Instructions.End
          }
          cases.foldLeft(cgExpr(scrut))((code, aCase) =>
            code<:>If_i32<:>matchAndBind(aCase.pat)<:>cgExpr(aCase.expr)((locals++maplocals), lh)<:>Else)<:>Unreachable<:>End
        }

        //  // Represents a computational error; prints its message, then exits
        //  case class Error(msg: Expr) extends Expr
        case Error(msg) => cgExpr(msg)<:>Call("Std_readString")<:>Instructions.Unreachable
      }

    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
